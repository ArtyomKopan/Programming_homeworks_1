# код в примерах приведён на Python, т.к. он наиболее легко читаемый и позволяет не заморачиваться с техническими деталями вроде выделения памяти, указателей и т.д., а сконцентрировать внимание на самом алгоритме

Пусть a - исходный массив размера n.
Назовём пару элементов сопряжённой, если они следуют друг за другом в массиве (пары вида (a[i], a[i+1])). Обозначим отношение сопряжённости как a[i] ~ a[j]. При нечётном n один из элементов (последний) может не иметь сопряжённого, но в нашем случае это не важно.
Худший случай сортировки слиянием подразумевает наибольшее число сравнений элементов. Вспомним алгоритм слияния массивов:
```
def merge(a, left, right):
	middle = (left + right) // 2
	i = 0 # i, j - итераторы
	j = 0
	res = [0 for i in range(right - left + 1)]
	while (left + i < middle) and (middle + j < right):
		if a[left + i] <= a[middle + j]:
			res[i + j] = a[left + i]
			i += 1
		else:
			res[i + j] = a[middle + j]
			j += 1
	while left + i < middle:
		res[i + j] = a[left + i]
		i += 1
	while middle + j < right:
		res[i + j] = a[middle + j]
		j += 1
	for i in range(right - left):
		a[left + i] = res[i]
```
Очевидно, что наибольшее количество сравнений достигается в том случае, когда i и j увеличиваются с одинаковой скоростью. Для этого нужно, чтобы случаи a[i] > a[j] и a[i] < a[j] должны чередоваться. В отсортированном массиве    a[i] ~ a[i+1] ==> a[i] < a[i+1] (по определению). Поэтому мы при разбиении массива на меньшие части перед слиянием отправляем сопряжённые элементы в разные части массива. Для чередования случаев a[i] > a[j] и a[i] < a[j] нужно, чтобы сопряжённые элементы становились на одинаковые позиции в сливаемых массивах (т.к. разность между ними минимальна по сравнению с разностью с любым другим элементом массива).

Построим пример наихудшего случая массива для сортировки слиянием.
Пусть отсортированный массив = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] (n = 10)
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
[2, 4, 6, 8, 10] [1, 3, 5, 7, 9]
[4, 8] [2, 6, 10] [3, 7] [1, 5, 9]
[8] [4] [6] [2, 10] [7] [3] [5] [1, 9]
[8] [4] [6] [10] [2] [7] [3] [5] [9] [1]

Таким образом, пример наихудшего массива: [8, 4, 6, 10, 2, 7, 3, 5, 9, 1]
При сортировке этого массива нужно сделать 25 сравнений, в то время как для любого другого массива такой длины количество сравнений не превышает 22.

Теперь напишем алгоритм построения наихудшего массива.
Функция createWorstArray принимает размер требуемого массива и строит наихудший массив требуемого размера, все элементы которого - целые числа от 1 до size.
```
def createWorstArray(size):
    if size == 1:
        return [1]
    leftArray = createWorstArray(floor(size / 2))
    rightArray = createWorstArray(ceil(size / 2))
    for i in range(len(leftArray)):
        leftArray[i] = leftArray[i] * 2
    for i in range(len(rightArray)):
        rightArray[i] = rightArray[i] * 2 - 1
    return leftArray + rightArray     # здесь оператор + означает, что rightArray дописывается в конец leftArray
```
